# IV. **网络**
## **一、 物理层**
## **二、 数据链路层**
## **三、 网络层**
#### 1. 路由器的功能？
路由选择与分组转发
#### 2. ip报文如何从下向上交付
#### 3. ip地址有什么用，ip地址和mac地址, 为什么需要IP地址
1) IP地址是在网络上分配给每台计算机或网络设备的32位数字标识。在Internet上，每台计算机或网络设备的IP地址是全世界唯一的。IP地址的格式是 xxx.xxx.xxx.xxx，其中xxx是 0 到 255 之间的任意整数。例如，每步站主机的IP地址是 219.134.132.131。
2) MAC地址是数据链路层的地址，如果mac地址不可直达 ,直接丢弃，在LAN里面，一个网卡的MAC地址是唯一的。MAC地址在arp协议里常常用到，mac地址到ip地址的相互转化。Mac地址是48位的地址。
3) IP地址是网络层的地址，如果ip地址不可达，接着转发，在WAN里面，ip地址不唯一，计算机的ip地址可以变动
#### 4. ARP协议的作用
ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存表（最近数据传递更新的IP-MAC地址对应表），如果查询的IP－MAC值对不存在，那么主机就向网络广播一个ARP请求包，这个包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就回应一个ARP应答包（将自己对应的IP-MAC对应地址发回主机），源主机拿到ARP应答包后会更新自己的ARP缓存表。源主机根据新的ARP缓存表准备好数据链路层的的数据包发送工作。
#### 5. NAT的原理，外网与内网或内网之间的通信中如何区分不同IP的数组包
**1. 公有IP地址：**也叫全局地址，是指合法的IP地址，它是由NIC（网络信息中心）或者ISP(网络服务提供商)分配的地址，对外代表一个或多个内部局部地址，是全球统一的可寻 址的地址。
**2. 私有IP地址：**也叫内部地址，属于非注册地址，专门为组织机构内部使用。因特网分配编号委员会（IANA）保留了3块IP地址做为私有IP地址；
3. NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，它是一个IETF(Internet Engineering Task Force, Internet工程任务组)标准，允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术，如下图所示。因此我们可以认为，NAT在一定程度上，能够有效的解决公网地址不足的问题。
4. NAT就是在局域网内部网络中使用内部地址，而当内部节点要与外部网络进行通讯时，就在网关（可以理解为出口，打个比方就像院子的门一样）处，将内部地址替换成公用地址，从而在外部公网（internet）上正常使用，NAT可以使多台计算机共享Internet连接，这一功能很好地解决了公共 IP地址紧缺的问题。通过这种方法，可以只申请一个合法IP地址，就把整个局域网中的计算机接入Internet中。这时，NAT屏蔽了内部网络，所有内部网计算机对于公共网络来说是不可见的，而内部网计算机用户通常不会意识到NAT的存在。
#### 6. RIP路由协议
1. 网络中的每一个路由器都要维护从它自己到其他每一个目标网络的距离记录；
2. 距离也称为跳数，规定从一路由器到直接连接的网络跳数为1，而每经过一个路由器，则距离加1；
3. RIP认为好的路由就是它通过的路由器数量最少；
4. RIP允许一条路径上最多有15个路由器，因为规定最大跳数为16；
5. RIP默认每30秒广播一次RIP路由更新信息。
​

每一个路由表项目包括三个内容：目的网络、距离、下一跳路由器
1、 对地址为X的路由器发过来的路由表，先修改此路由表中的所有项目：把”下一跳”字段中的地址改为X，并把所有”距离”字段都加1。
2、 对修改后的路由表中的每一个项目，进行以下步骤： 
2.1、将X的路由表(修改过的)，与S的路由表的目的网络进行对比。 
若在X中出现，在S中没出现，则将X路由表中的这一条项目添加到S的路由表中。 
2.2、对于目的网络在S和X路由表中都有的项目进行下面步骤 
2.2.1、在S的路由表中，若下一跳地址是x 
则直接用X路由表中这条项目替换S路由表中的项目。 
2.2.2、在S的路由表中，若下一跳地址不是x 
若X路由表项目中的距离d小于S路由表中的距离，则进行更新。 
3、 若3分钟还没有收到相邻路由器的更新表，则把此相邻路由器记为不可到达路由器，即把距离设置为16。
#### 7. 为什么使用IP地址通信
1) 由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。
2) 连接到因特网的主机都拥有统一的IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为调用ARP 来寻找某个路由器或主机的硬件地址都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。  
#### 8. 子网掩码有什么用？
子网掩码是一种用来指明一个IP地址所标示的主机处于哪个子网中。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成[网络地址](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80)和[主机地址](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80)两部分。
#### 9. 子网划分的方法
1) 传统子网划分，ip地址结构=网络号+主机号
2) 子网掩码
3) CIDR，减少了传统分法的ip浪费。
## **四、 运输层**
#### 1. TCP协议有几大计时器？
1) 重传计时器
在一个TCP连接中，TCP每发送一个报文段，就对此报文段设置一个超时重传计时器。若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。
2) 持续计时器
为了对付零窗口大小通知，TCP需要另一个计时器。假定接收TCP宣布了窗口大小为零。发送TCP就停止传送报文段，直到接收TCP发送确认并宣布一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认是不需要发送确认的。若确认丢失了，接收TCP并不知道，而是会认为它已经完成任务了，并等待着发送TCP接着会发送更多的报文段。但发送TCP由于没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。要打开这种死锁，TCP为每一个连接使用一个坚持计时器。当发送TCP收到一个窗口大小为零的确认时，就启动坚持计时器。当坚持计时器期限到时，发送TCP就发送一个特殊的报文段， 叫做 探测报文段 。这个报文段只有一个字节的数据。它有一个序号，但它的序号永远不需要确认；甚至在计算对其他部分的数据的确认时该序号也被忽略。探测报文段提醒对端：确认已丢失，必须重传。 
3) 保活计时器
保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处理打开状态。 
4) 时间等待计时器
时间等待计时器是在连接终止期间使用的。当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。在时间等待期间中，连接还处于一种中间过渡状态。这就可以使重复的FIN报文段（如果有的话）可以到达目的站因而可将其丢弃。这个计时器的值通常设置为一个报文段的寿命期待值的两倍。
#### **2. 详细说一下TCP协议，三次握手传输的内容？13种状态**
​

1) 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
2) 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
3) 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

​

那四次分手呢？
当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。
1) 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
2) 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
3) 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
4) 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。
5) 六大标志位
SYN，同步标志位；ACK确认标志位；PSH传送标志位；FIN结束标志位；RST重置标志位；URG紧急标志位；seq序号；ack确认号
​

#### **3. TCP为啥挥手要比握手多一次？**
因为当处于LISTEN状态的服务器端收到来自客户端的SYN报文(客户端希望新建一个TCP连接)时，它可以把ACK(确认应答)和SYN(同步序号)放在同一个报文里来发送给客户端。但在关闭TCP连接时，当收到对方的FIN报文时，对方仅仅表示对方已经没有数据发送给你了，但是你自己可能还有数据需要发送给对方，则等你发送完剩余的数据给对方之后，再发送FIN报文给对方来表示你数据已经发送完毕，并请求关闭连接，所以通常情况下，这里的ACK报文和FIN报文都是分开发送的。
#### **4. 为什么一定进行三次握手？**
当客户端向服务器端发送一个连接请求时，由于某种原因长时间驻留在网络节点中，无法达到服务器端，由于TCP的超时重传机制，当客户端在特定的时间内没有收到服务器端的确认应答信息，则会重新向服务器端发送连接请求，且该连接请求得到服务器端的响应并正常建立连接，进而传输数据，当数据传输完毕，并释放了此次TCP连接。若此时第一次发送的连接请求报文段延迟了一段时间后，到达了服务器端，本来这是一个早已失效的报文段，但是服务器端收到该连接请求后误以为客户端又发出了一次新的连接请求，于是服务器端向客户端发出确认应答报文段，并同意建立连接。如果没有采用三次握手建立连接，由于服务器端发送了确认应答信息，则表示新的连接已成功建立，但是客户端此时并没有向服务器端发出任何连接请求，因此客户端忽略服务器端的确认应答报文，更不会向服务器端传输数据。而服务器端却认为新的连接已经建立了，并在一直等待客户端发送数据，这样服务器端一直处于等待接收数据，直到超出计数器的设定值，则认为服务器端出现异常，并且关闭这个连接。在这个等待的过程中，浪费服务器的资源。如果采用三次握手，客户端就不会向服务器发出确认应答消息，服务器端由于没有收到客户端的确认应答信息，从而判定客户端并没有请求建立连接，从而不建立该连接。
#### **5. TCP与UDP的区别？应用场景都有哪些？**
1) TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2) TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
3) UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
4) 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5) TCP对系统资源要求较多，UDP对系统资源要求较少。
6) 若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。
7) UDP:DNS   SNMP
8) TCP面向字节流，UTP面向数据包；
#### **6. 为什么UDP有时比TCP更有优势?**
1) 网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。
2) TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。
3) 采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。 
#### **7. UDP中一个包的大小最大能多大**
1) 以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这这个MTU指的是链路层的数据区.
2) 并不包括链路层的首部和尾部的18个字节.所以,事实上,这个1500字节就是网络层IP数据报的长度限制.因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节.    
3) 而这个1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的.又因为UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节.这个1472字节就是我们可以使用的字节数。
#### **8. TCP 粘包**
1) 在socket网络程序中，TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。
2) 对于UDP，不会使用块的合并优化算法，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。所以UDP不会出现粘包问题
​

1) TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾；
2) 发送方原因
我们知道，TCP默认会使用Nagle算法。而Nagle算法主要做两件事：1）只有上一个分组得到确认，才会发送下一个分组；2）收集多个小分组，在一个确认到来时一起发送。所以，正是Nagle算法造成了发送方有可能造成粘包现象。
3) 接收方原因
TCP接收到分组时，并不会立刻送至应用层处理，或者说，应用层并不一定会立即处理；实际上，TCP将收到的分组保存至接收缓存里，然后应用程序主动从缓存里读收到的分组。这样一来，如果TCP接收分组的速度大于应用程序读分组的速度，多个包就会被存至缓存，应用程序读时，就会读到多个首尾相接粘到一起的包。
4) 解决方法
**① 发送方**
对于发送方造成的粘包现象，我们可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭Nagle算法。
**② 接收方**
遗憾的是TCP并没有处理接收方粘包现象的机制，我们只能在应用层进行处理。
**③ 应用层处理**
应用层的处理简单易行！并且不仅可以解决接收方造成的粘包问题，还能解决发送方造成的粘包问题。
#### **9. 传输层功能**
传输进程到进程的逻辑通信，即所说的端到端的通信，而网络层完成主机到主机之间的逻辑通信；
#### **10. TCP可靠性保证**
1. 序号
TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据看成无结构的有序的字节流。数据流中的每一个字节都编上一个序号字段的值是指本报文段所发送的数据的第一个字节序号。
2. 确认
TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号；
3. 重传
超时重传
冗余ACK重传
4. 流量控制
TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。
发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值(可增大或减小)。
1) 窗口
接受窗口rwnd，接收端缓冲区大小。接收端将此窗口值放在TCP 报文的首部中的窗口字段，传送给发送端。
拥塞窗口cwnd，发送缓冲区大小。
发送窗口swnd, 发送窗口的上限值 = Min [rwnd, cwnd]
5. 拥塞控制
6. 流量控制与拥塞控制的区别
所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。
#### **11. 拥塞控制**
1) 慢开始
发送方维持一个叫做**拥塞窗口cwnd（congestion window）**的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。
当然收到单个确认但此确认多个数据报的时候就加相应的数值。所以一次传输轮次之后拥塞窗口就加倍。这就是乘法增长，和后面的拥塞避免算法的加法增长比较。
为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：
**当cwnd<ssthresh时，使用慢开始算法。**
**当cwnd>ssthresh时，改用拥塞避免算法。**
**当cwnd=ssthresh时，慢开始与拥塞避免算法任意。**
拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。
无论是在**慢开始阶段**还是在**拥塞避免阶段**，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如下图：
​

2) 快重传和快恢复
快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
快重传配合使用的还有快恢复算法，有以下两个要点:
①当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。
②考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。如下图：
​

#### **12. TCP流量控制**
1) 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。TCP的流量控制是利用滑动窗口机制实现的，接收方在返回的ACK中会包含自己的接收窗口的大小，以控制发送方的数据发送。
2) 当某个ACK报文丢失了，就会出现A等待B确认，并且B等待A发送数据的死锁状态。为了解决这种问题，TCP引入了持续计时器（Persistence timer），当A收到rwnd=0时，就启用该计时器，时间到了则发送一个1字节的探测报文，询问B是很忙还是上个ACK丢失了，然后B回应自身的接收窗口大小，返回仍为0（A重设持续计时器继续等待）或者会重发rwnd=x。
#### **13. 流量控制与拥塞控制的区别？**
1) 拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。
2) 所谓流量控制就是让发送发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制。原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。
#### **14. time_wait与close_wait，time_wait状态持续多长时间？为什么会有time_wait状态？**
1) time_wait另一边已经初始化一个释放，close_wait连接一端被动关闭；
2) 首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL指的是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。
3) 为什么存在time_wait
① TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误。因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态 。
​

​

**为实现TCP全双工连接的可靠释放**
由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。
② TCP segment 可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个segment，迷途的segment在路由器修复后也会被送到最终目的地，这个迟到的迷途segment到达时可能会引起问题。在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的迷途重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。
​

​

**为使旧的数据包在网络因过期而消失**
为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。
4) 如果time_wait维持的时间过长，主动关闭连接端迟迟无法关闭连接，占用程序资源。
5) 如果服务器程序TCP连接一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。
6) time_wait状态如何避免
首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。
​

	**Close_wait:**
1) 产生原因
在被动关闭连接情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。通常来讲，CLOSE_WAIT状态的持续时间应该很短，正如SYN_RCVD状态。但是在一些特殊情况下，就会出现连接长时间处于CLOSE_WAIT状态的情况。出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。代码需要判断socket，一旦读到0，断开连接，read返回负，检查一下errno，如果不是AGAIN，就断开连接。对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。
2) 解决方法
要检测出对方已经关闭的socket，然后关闭它。
#### 15. Time_wait为什么是2MSL的时间长度
TIME_WAIT的状态是为了等待连接上所有的分组的消失。单纯的想法，发送端只需要等待一个MSL就足够了。这是不够的，假设现在一个MSL的时候，接收端需要发送一个应答，这时候，我们也必须等待这个应答的消失，这个应答的消失也是需要一个MSL，所以我们需要等待2MSL。
#### 16. 介绍一下ping的过程，分别用到了哪些协议
#### 17. socket编程
**TCP过程：**
客户端：
1) 创建socket
2) 绑定ip、端口号到socket字
3) 连接服务器，connect()
4) 收发数据，send()、recv()
5) 关闭连接
服务器端：
1) 创建socket字
2) 设置socket属性
3) 绑定ip与端口号
4) 开启监听，listen()
5) 接受发送端的连接accept()
6) 收发数据send()、recv()
7) 关闭网络连接
8) 关闭监听
​

对应关系：
客户端的connect()指向服务器端的accept()
客户端、服务器端的send()/recv()是双向箭头的关系。
​

**UDP过程：**
**​**

#### 18. 客户端为什么不需要bind
#### 19. send和recv的缺点
## **五、 应用层**
#### 1. 常用的网络协议？
1) DHCP
动态主机设置协议（Dynamic Host Configuration Protocol, DHCP）是一个局域网的网络协议，使用[UDP协议](https://www.baidu.com/s?wd=UDP%E5%8D%8F%E8%AE%AE&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址给用户给内部[网络管理员](https://www.baidu.com/s?wd=%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%98&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)作为对所有计算机作中央管理的手段
2) ARP
将32位的IP地址转换为48位的物理地址。当路由器或主机选择了某条路由时，首先会查找ARP缓存，若缓存中有对应IP地址的物理地址，则以此封装以太帧，否则会广播（为二层广播）ARP报文，每个主机接收到ARP请求报文后，会缓存发送源的IP——MAC对到ARP缓存中，目的主机会发送ARP回应（此时为单播），当发送源接收到回应时，会将目的方的IP——MAC对存放在ARP缓存中。在点到点的物理连接中，是不会用到ARP报文的，在启动时双方都会通告对方自己的IP地址，此时物理层的封装不需要MAC地址。windows上可以使用arp -a查看本机的ARP缓存。ARP缓存中的每个条目的最大存活时间为20分钟
3) ICMP
ICMP（Internet Control Message Protocol）因特网控制报文协议。它是IPv4协议族中的一个子协议，用于IP主机、路由器之间传递控制消息。控制消息是在网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然不传输用户数据，但是对于用户数据的传递起着重要的作用。 
ICMP协议与ARP协议不同，ICMP靠IP协议来完成任务，所以ICMP报文中要封装IP头部。它与传输层协议（如TCP和UDP）的目的不同，一般不用来在端系统之间传送数据，不被用户网络程序直接使用，除了想Ping和Tracert这样的诊断程序。
#### 2. 网络协议各个层的网络设备？
一、集线器
集线器也称HUB，工作在OSI七层结构的第一层物理层，属于共享型设备，接收数据广播发出，在局域网内一般都是星型连接拓扑结构，每台工作站都连接到集线器上。由于集线器的带宽共享特性导致网络利用效率极低，一般在大中型的网络中不会使用到集线器。现在的集线器基本都是全双工模式，市面上常见的集线器传输速率普遍都为100Mbps。
二、中继器
中继器（Repeater）工作于OSI的第一层（物理层），中继器是最简单的网络互联设备，连接同一个网络的两个或多个网段，主要完成物理层的功能，负责在两个网络节点的物理层上按位传递信息，完成信号的复制、调整和放大功能，以此从而增加信号传输的距离，延长网络的长度和覆盖区域，支持远距离的通信。
一般来说，中继器两端的网络部分是网段，而不是子网。中继器只将任何电缆段上的数据发送到另一段电缆上，并不管数据中是否有错误数据或不适于网段的数据。大家最常接触的是网络中继器，在通讯上还有微波中继器、激光中继器、红外中继器等等，机理类似，触类旁通。
三、交换机
交换机顾名思义以交换为主要功能，工作在OSI第二层（数据链路层），根据MAC地址进行数据转发。交换机的每一个端口都属于一个冲突域，而集线器所有端口属于一个冲突域。交换机通过分析Ethernet包的包头信息（其中包含了源MAC地址、目标MAC地址、信息长度等），取得目标MAC地址后，查找交换机中存储的地址对照表（MAC地址对应的端口），确认具有此MAC地址的网卡连接在哪个端口上，然后将信包送到对应端口，有效的抑制IP广播风暴。并且信息包处于并行状态，效率较高。
交换机的转发延迟非常小，主要的得益于其硬件设计机理非常高效，为了支持各端口的最大数据传输速率，交换机内部转发信包的背板带宽都必须远大于端口带宽，具有强大的整体吞吐率，才能为每台工作站提供更高的带宽和更高的网络利用率，可以满足大型网络环境大量数据并行处理 的要求。
四、网桥
网桥和交换机一样都是工作在OSI模型的第二层（数据链路层），可以看成是一个二层路由器（真正的路由器是工作在网络层，根据IP地址进行信包转发）。网桥可有效的将两个局域网（LAN）连起来，根据MAC地址（物理地址）来转发帧，使本地通信限制在本网段内，并转发相应的信号至另一网段，网桥通常用于联接数量不多的、同一类型的网段。
五、路由器
路由器跟集线器和交换机不同，是工作在OSI的第三层（网络层），根据IP进行寻址转发数据包。路由器是一种可以连接多个网络或网段的网络设备，能将不同网络或网段之间（比如局域网——大网）的数据信息进行转换，并为信包传输分配最合适的路径，使它们之间能够进行数据传输，从而构成一个更大的网络。
路由器具有最主要的两个功能，即数据通道功能和控制功能。数据通道功能包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成；控制功能一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等。
六、网关
网关（Gateway）又叫协议转换器，网关的概念实际上跟上面的设备型不是一类问题，但是为了方便参考还是放到这里一并介绍。
网关是一种复杂的网络连接设备，可以支持不同协议之间的转换，实现不同协议网络之间的互连。网关具有对不兼容的高层协议进行转换的能力，为了实现异构设备之间的通信，网关需要对不同的链路层、专用会话层、表示层和应用层协议进行翻译和转换。所以网关兼有路由器、网桥、中继器的特性。
若要使两个完全不同的网络（异构网）连接在一起，一般使用网关，在Internet中两个网络也要通过一台称为网关的计算机实现互联。这台计算机能根据用户通信目标计算机的IP地址，决定是否将用户发出的信息送出本地网络，同时，它还将外界发送给属于本地网络计算机的信息接收过来，它是一个网络与另一个网络相联的通道。为了使TCP/IP协议能够寻址，该通道被赋予一个IP地址，这个IP地址称为网关地址。
所以，网关的作用就是将两个使用不同协议的网络段连接在一起的设备，对两 个网络段中的使用不同传输协议的数据进行互相的翻译转换。在互连设备中，由于协议转换的复杂性，一般只能进行一对一的转换，或是少数几种特定应用协议的转换。
#### 3. 讲讲浏览器输入地址后发生的全过程，以及对应的各个层次的过程
1、域名解析：浏览器获得URL地址，向操作系统请求该URL对应的IP地址，操作系统查询DNS（首先查询本地HOST文件，没有则查询网络）获得对应的IP地址
解释：
把URL分割成几个部分：协议、网络地址、资源路径
协议：指从该计算机获取资源的方式，常见的是HTTP、FTP
网络地址：可以是域名或者是IP地址，也可以包括端口号，如果不注明端口号，默认是80端口
如果地址不是一个IP地址，则需要通过DNS（域名系统）将该地址解析成IP地址，IP地址对应着网络上的一台计算机，DNS服务器本身也有IP，你的网络设置包含DNS服务器的IP，例如，www.abc.com不是一个IP，则需要向DNS询问请求www.abc.com对应的IP，获得IP，在这个过程中，你的电脑直接询问DNS服务器可能没有发现www.abc.com对应的IP，就会向它的上级服务器询问，这样依次一层层向上级找，最高可达根节点，直到找到或者全部找不到为止
端口号就相当于银行的窗口，不同的窗口负责不同的服务，如果输入www.abc.com:8080/，则表示不使用默认的80端口，而使用指定的8080端口
2、确认好了IP和端口号，则可以向该IP地址对应的服务器的该端口号发起TCP连接请求
3、服务器接收到TCP连接请求后，回复可以连接请求，
4、浏览器收到回传的数据后，还会向服务器发送数据包，表示三次握手结束
5、三次握手成功后，开始通讯，根据HTTP协议的要求，组织一个请求的数据包，里面包含请求的资源路径、你的身份信息等，例如，www.abc.com/images/1/表示的资源路径是images/1/，发送后，服务器响应请求，将数据返回给浏览器，数据可以是根据HTML协议组织的网页，里面包含页面的布局、文字等等，也可以是图片或者脚本程序等，如果资源路径指定的资源不存在，服务器就会返回404错误，如果返回的是一个页面，则根据页面里的一些外链URL地址，重复上述步骤，再次获取
6、渲染页面，并开始响应用户的操作
7、窗口关闭时，浏览器终止与服务器的连接
#### 4. http与https工作方式
1) http包含如下动作：
① 浏览器打开一个TCP连接；
② 浏览器发送HTTP请求到服务器；
③ 服务器发送HTTP回应信息到服务器；
④ TCP连接关闭；
2) SSL包含如下动作：
① 验证服务器端；
② 允许客户端和服务器端选择加密算法和密码，确保双方都支持；
③ 验证客户端；
④ 使用公钥加密技术来生成共享加密数据；
⑤ 创建一个加密的SSL连接；
⑥ 基于该SSL连接传递HTTP请求；
#### 5. http协议，http和https的区别
1) HTTP和HTTPS的基本概念
HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
2) HTTPS和HTTP的区别主要如下：
a) https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
b) http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
c) http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
d) http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
e) 在OSI模型中，HTTP工作于应用层，而HTTPS工作于传输层；
#### 6. http状态码
1) 1XX    信息码，服务器收到请求，需要请求者继续执行操作；
2) 2XX    成功码，操作被成功接收并处理；
3) 3XX    重定向，需要进一步的操作以完成请求；
4) 4XX    客户端错误，请求包含语法错误或无法完成请求；
5) 5XX    服务器错误，服务器在处理请求的过程中发生了错误
​

​

404   服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
#### 7. HTTP1.0与HTTP1.1的区别？
1) HTTP1.0需要使用keep-alive参数来告知服务器要建立一个长连接，而HTTP1.1默认支持长连接；
2) HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401；
3) HTTP1.0是没有host域的，HTTP1.1才支持这个参数；
4) HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级；
5) HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快；
6) 对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源
#### 8. OSI 7层网络模型中各层的名称及其作用？
	
#### 9. TCP/IP 4层网络模型名称及其作用？
​

#### 10. OSI 7层网络中各层的常见协议以及协议作用？设备
第一层：物理层(PhysicalLayer)
规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。具体地讲，机械 特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等;电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率 距离限制等;功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能;规程特性定义了利用信号线进行bit流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是，DTE和DCE双放在各电路上的动作系列。在这一层，数据的单位称为比特(bit)。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等。
第二层：数据链路层(DataLinkLayer)
在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧(Frame)在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧(frame)。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。
第三层是网络层
在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。如 果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议(ARP)。有关路由的一切事情都在这第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包(packet)。网络层协议的代表包括：IP、IPX、RIP、OSPF等。
第 四层是处理信息的传输层
第4层的数据单元也称作数据包(packets)。但是，当你谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段 (segments)而UDP协议的数据单元称为“数据报(datagrams)”。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端(最终用户到最终用户)的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等。
第五层是会话层
这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。
第六层是表示层
这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。
第七层应用层
应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等
#### 11. OSI与TCP模型的区别？
1) TCP/IP协议中的应用层处理开放式系统互联模型中的第五层、第六层和第七层的功能；
2) TCP/IP协议中的传输层并不能总是保证在传输层可靠地传输数据包，而开放式系统互联模型可以做到。TCP/IP协议还提供一项名为UDP(用户数据报协议)的选择。UDP不能保证可靠的数据包传输。
#### 12. DNS是干什么的？？
1) 主机解析域名的顺序
找缓存、找本机的hosts文件、找DNS服务器
2) DNS协议运行在UDP协议之上，使用端口号53
3) 根服务器：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器，依次类推）
​

	十个过程：
① 浏览器先检查自身缓存中有没有被解析过这个域名对应的ip地址；
② 如果浏览器缓存没有命中，浏览器会检查操作系统缓存中有没有对应的已解析过的结果。在windows中可通过c盘里hosts文件来设置；
③ 还没命中，请求本地域名服务器来解析这个域名，一般都会在本地域名服务器找到；
④ 本地域名服务器没有命中，则去根域名服务器请求解析；
⑤ 根域名服务器返回给本地域名服务器一个所查询域的主域名服务器；
⑥ 本地域名服务器向主域名服务器发送请求；
⑦ 接受请求的主域名服务器查找并返回这个域名对应的域名服务器的地址；
⑧ 域名服务器根据映射关系找到ip地址，返回给本地域名服务器；
⑨ 本地域名服务器缓存这个结果；
⑩ 本地域名服务器将该结果返回给用户；
#### **13.  **get/post 区别
1) 后退按钮或刷新，Get无害，post数据会被重新提交；
2) Get所使用的URL可以被设置为书签，而post不可以；
3) Get能够被缓存，而post不可以；
4) Get参数保留在浏览器历史中，而post参数不会保留在浏览器历史中；
5) 当发生数据时，get方法向URL添加数据，URL的数据长度是受限的，而post没有数据长度限制；
6) Get只允许ASCII编码，而post没有限制；
7) Get安全性没有post安全性好；
8) Get数据在URL中对所有人是可见的，而在post中数据不会显示在URL中。
9) Get产生一个TCP数据包，post产生两个TCP数据包；对于get方式的请求，浏览器会把header和data一并发送出去；对于post，浏览器先发送header再发送data；
10) GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同；
#### **14. 说一下网卡从接收到数据后发生了什么**
#### 15. send函数什么情况下会阻塞
#### 16. 常用端口号
FTP 21;TELNET 23;SMTP  25;DNS  53;HTTP 80;HTTPS 443
#### 17. https的过程
​

# V. **数据结构**
### 1. 常用查找算法？具体实现
### 2. 常用排序算法？具体实现，哪些是稳定的，时间复杂度、空间复杂度，快速排序非递归如何实现？快排的优势？
### 3. 图的常用算法？
1) 深度广度遍历；
2) 广度优先遍历；
3) 最短路径Floyed算法；
4) 最短路径Dijktral算法；
5) 最小生成树，Prime算法；
6) 最小生成树Kuraul算法；
### 4. 哈夫曼编码？
1) 给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
2) 哈夫曼树的构造
将节点权重进行升序排序；
选择权重最小的两个节点，将两个节点的和作为新节点，将新节点加入数组中；
重复以上步骤，最后数组中剩下一个值，该值就是树的带权路径长度，即哈夫曼树；
### 5. ***AVL树、B+树、红黑树、B树B+树区别，B+树应用在哪里？
1) 一个m阶的B+树具有如下特征：
① 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
② 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
③ 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。
④ 在B+树中，只有叶子节点带有数据，其余中间节点仅仅是索引，没有关联任何数据。
2) B+树的优势
① 单一节点存储更多的元素，使得查询的IO次数更少；
② 所有查询都要查询到叶子节点，查询性能稳定；
③ 所有叶子节点形成有序链表，便于范围查询；
3) B+树与B-树的区别
​

​

### 6. 为什么使用红黑树，什么情况使用AVL树。红黑树比AVL树有什么优点。
1) 首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高！！！红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多。
2) 如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。
### 7. 单链表如何判断有环？ 
1) 在链表头部设置两个指针，一个每次向后移动两个位置，一个每次向后移动一个位置。两个指针遍历链表过程中，如果快指针到达链表尾还没有和慢指针相遇，说明链表无环，反之有环；
2) 环的长度，从两个指针的交点开始，移动指针，当指针再次指向两个指针的交点的时候，就可以求出环的长度；
3) 环的入口，一个指针从头开始，一个指针指向(1)中的环中快慢指针的交点，开始遍历，直到这两个指针相遇，两个指针相遇的点就是环的入口点。
### 8. 如何判断一个图是否连同？
可以用DFS（O（v^2））和BFS(O(v+e))的思想都能实现，只要从一个点出发，然后判断是否能遍历完所有的点。
### 9. hash用在什么地方，解决hash冲突的几种方法?负载因子？
1) 如何构造哈希函数
a) 数字分析法；
b) 平方取中法；
c) 除留余数法；
d) 伪随机数法；
2) 处理冲突
e) 线性探测；
f) 二次探测；
g) 伪随机数探测；
h) 拉链探测。
3) 如果负载因子是默认的0.75，HashMap(16)的时候，占16个内存空间，实际上只用到了12个，超过12个就扩容。
如果负载因子是1的话，HashMap(16)的时候，占16个内存空间，实际上会填满16个以后才会扩容。增大负载因子可以减少hash表的内存，如果负载因子是0.75，hashmap(16)最多可以存储12个元素，想存第16个就得扩容成32。如果负载因子是1，hashmap(16)最多可以存储16个元素。同样存16个元素，一个占了32个空间，一个占了16个空间的内存。
### 10. n个节点的二叉树的所有不同构的个数
### 11. 二叉树的公共祖先，排序二叉树的公共祖先
1) 搜索二叉树
从树的根节点开始和两个节点进行比较，如果根节点大于两个节点值，则去根节点的左孩子去进行查找；如果根节点小于两个节点值，则去根节点的右孩子去进行查找；当根节点大于其中一个节点，小于其中一个节点，则该节点是最近的祖先节点。
方法一首先给出node1的父节点node1->_parent，然后将node1的所有父节点依次和node2->parent作比较，如果发现两个节点相等，则该节点就是最近公共祖先，直接将其返回。如果没找到相等节点，则将node2的所有父节点依次和node1->_parent->_parent作比较......直到node1->_parent==NULL。
方法二给定的两个节点都含有父节点，因此，可将这两个节点看做是两个链表的头结点，将求两个节点的最近公共祖先节点转化为求两链表的交点，这两个链表的尾节点都是根节点。
2) 一般二叉树
方法一，将从根节点到node1的路径保存在数组中；将从根节点到node2的路径保存在数组中；两个数组从头开始遍历，直到找到不相同的两个值，该值前一个就是最近祖先；
方法二，从根节点开始遍历，如果node1和node2中的任一个和root匹配，那么root就是最低公共祖先。 如果都不匹配，则分别递归左、右子树，如果有一个 节点出现在左子树，并且另一个节点出现在右子树，则root就是最低公共祖先.  如果两个节点都出现在左子树，则说明最低公共祖先在左子树中，否则在右子树。
### 12. 节点的最大距离
1) 如果具有最远距离的两个节点经过根节点，那么最远的距离就是左边最深的深度加上右边最深的深度之和；如果具有最远距离的两个节点之间的路径不经过根节点，那么最远的距离就在根节点的其中一个子树上的两个叶子节点。
int _Height(root, distance)
{
	if(root为空)
		return 0;
	left = _Height(左子树)；
	right = _Height(右子树)；
	if(left+right>distance)
		distance = left+right;
	return 左子树、右子树较大加1；
}
### 13. 把一颗二叉树原地变成一个双向链表
递归中序遍历；
### 14. 二叉树的所有路径
vector<string> binaryTreePaths(TreeNode* root) {
// Write your code here
vector<string> res;
if(root==NULL) return res;
binaryTreePathsCore(root,res,to_string(root->val));
return res;
}
​ 
void binaryTreePathsCore(TreeNode* root,vector<string> &str,string strpath){
​ 
if(root->left==NULL&&root->right==NULL){
//叶子结点
str.push_back(strpath);
return;
}
if(root->left!=NULL){
binaryTreePathsCore(root->left,str,strpath+"->"+to_string(root->left->val));
}
if(root->right!=NULL){
binaryTreePathsCore(root->right,str,strpath+"->"+to_string(root->right->val));
}
}
### 15. 二叉树中寻找每一层中最大值？
1) 利用队列来分别将每层的树添加进队列进行分析，先记录下第一个值作为最大值并弹出，然后往后边比较边弹出，如果当前值比前面的最大值还要大则替换当前最大值。在弹出每次的节点时将孩子节点加进队列。直到整棵树被遍历完。
2) 伪代码
if(根节点为空)
	返回
申请队列Q，将根节点入队列
While(队列不空)
{
	s=队列长度
	for(i=0;i < s;i++)
	{
		比较队首元素，并将队首元素出栈
		队首左孩子入栈，右孩子入栈
}
}
### 16. 最大深度、最小深度、会否是平衡树
1) 二叉树的深度等于二叉树的高度，也就等于根节点的高度。根节点的高度为左右子树的高度较大者+1。 
int deepth(root)
{
	if(root为空)
		return 0;
	else
	{
		left = deepth(左孩子)；
		right = deepth(右孩子)；
		return left>right? left+1:right+1;
	}
}
2) 求最大深度的时候，只需要比较左右子树的深度，取较大者+1就行了；但是求最小深度的时候，需要区分双子树与单子树，双子树时，深度较小者+1，单子树时（即左右子树有一颗为空时）为深度较大者+1。 
int deepth(root)
{
	if(root为空)
		return 0;
	left = deepth(左孩子)；
	right = deepth(右孩子)；
	if(左孩子或有孩子为空)
		return 不为空的深度+1；
	return 左右较小者+1；
}
3) 判断平衡二叉树，只需要判断平衡因子小于1即可，递归判断左右节点是否是平衡的即可；
bool isBalance(root)
{
	left = 根节点左孩子高度；
	right = 根节点右孩子高度；
	if(right与left不满足平衡因子)
		return false;
	return isBalance(左孩子)&&isBalance(右孩子)；
}
### 17. 二叉树中叶子节点的数量
1) 叶子节点就是左右孩子都是空的节点，在进行遍历的过程中，判断是否为叶子节点，如果是叶子节点，将计数器加1；
2) 伪代码
void leafNodeNum(root,k)
{
	if(树为空)
		return;
	if(root不为空)
	{
		if(叶子节点)
			k++;
		leafNodeNum(root->左孩子,k)；
		leafNodeNum(root->右孩子,k)；
	}
}
### 18. 交换左右孩子、二叉树镜像
1) 递归交换左右孩子，从跟节点开始交换，节点的左右孩子不都为空，则进行交换操作；否则返回；
void exchangeChild(root)
{
	if(root->left空&&root->right空)
		return;
	swap(root->left,root->right);
	exchangeChild(root->left);
	exchangeChild(root->right);
}
### 19. 两个二叉树是否相等
1) 判断两颗树的根节点是否相同，如果不相同返回false，如果相同则递归判断根节点的左右子节点；如果两颗树中有一个树没有遍历完则说明不相等；两棵树都为空则两棵树相等；两棵树一颗为空一颗不为空则不相等；
bool treesEqual(root1,root2)
{
	if(root1空 && root2空)
		return true;
	if(root1空 || root2空)
		return false;
	if(root1->data == root2->data)
		return treesEqual(root1->left,root2->left)&&treesEqual(root1->right,root2->right);
	else
		return false;
}
### 20. 是否为完全二叉树
1) 如果一个结点有右孩子而没有左孩子，那么这棵树一定不是完全二叉树。 
如果一个结点有左孩子，而没有右孩子，那么按照层序遍历的结果，这个结点之后的所有结点都是叶子结点这棵树才是完全二叉树。 
如果一个结点是叶子结点，那么按照层序遍历的结果，这个结点之后的所有结点都必须是叶子结点这棵树才是完全二叉树。 
用一个标记变量leaf标记，当一个节点有左孩子无右孩子，leaf=true。之后所有的节点必须为叶子节点。
### 21. 是否为对称二叉树
bool isSymmetrical(root1,root2)
{
	if(root1空 && root2空)
		return true;
	if(root1空 || root2空)
		return false;
	if(root1->data != root2->data)
		return false;
	else
	return isSymmetrical(root1->left,root2->right)&&isSymmetrical(root1->right,root2->left);
}
### 22. 判断B是否为A的子树
1) 找值相同的根结点（遍历解决）
判断两结点是否包含（递归：值、左孩子、右孩子分别相同）
bool isPart(root1,root2)
{
	if(root1空&&root2空)
		return true;
	if(root1空 || root2空)
		return false;
	if(root1->data != root2->data)
		return false;
	else
		return isPart(root1->left,root2->left)&&isPart(root1->right,root2->right);
}
bool isPartTree(root1,root2)
{
if (root1不空 && root2不空)
{
if (root1->data == root2->data)
result = IsPart(root1, root2);
if (!result)
result = IsPartTree(root1->left, root2);
if (!result)
result = IsPartTree(root1->right, root2);
}
return result;
}
### 23. 构建哈夫曼树
### 24. 手写单链表反转？删除指定的单链表的一个节点
1. 单链表反转：尾插法转头查法；设置三个指针，当前节点指针，下一个节点指针，上一个节点指针，一开始上一个节点指针置为空；最后当下一个节点指针为空时说明到达最后节点，则返回该节点指针。
2. 删除指定节点：如果我们把要删除节点的下一个节点的内容复制到需要删除的节点上，然后把删除节点的下一个节点删除，就可以完成删除该节点，同时时间复杂度为O(1)。如果是尾节点，只能遍历删除，如果只有一个节点，还要删除头节点。
### 25. 实现一个循环队列
循环中front与rear的求值。
队首指针进1：front = (front+1)%MaxSize;
队尾指针进1：rear = (rear+1)%MaxSize;
队空：rear == front;
队满：(rear+1)%MaxSize == front
### 26. Top K问题
1) 如果要找前K个最大的数，我们用最小堆，每次用堆顶元素和遍历的数比，如果堆顶元素小，则让堆顶元素的值等于它，然后向下调整
2) 如果要找前K个最小的数，我们用最大堆，每次用堆顶元素和遍历的数比，如果堆顶元素大，则让堆顶元素的值等于它，然后向下调整
3) 用快速排序将数组进行排序，然后将数组输出
4) 两者的时间复杂度都是O（nlog2n）,快排的空间复杂度为O(log2n)，堆排序的空间复杂度为O(1)
### 27. 求一颗树的最大距离
对于二叉树，若要两个节点U，V相距最远，有两种情况：
1，从U节点到V节点之间的路径经过根节点
2，从U节点到V节点之间的路径不经过根节点，这种情况下，U，V节点必定在根节点的左子树或者右子树上，这样就转化为求以根节点的孩子节点为根节点的二叉树中最远的两个节点间的距离
### 28. KMP
核心是next（）函数的书写；
### 29. 数组和链表的区别?
1) 数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况，即数组的大小一旦定义就不能改变。当数据增加时，可能超出原先 定义的元素个数；当数据减少时，造成内存浪费；链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删 除数据项时，需要移动其它数据项）。 
2) （静态)数组从栈中分配空间（用NEW创建的在堆中）, 对于程序员方便快速,但是自由度小；链表从堆中分配空间, 自由度大但是申请管理比较麻烦.
3) 数组在内存中是连续存储的，因此，可以利用下标索引进行随机访问；链表是链式存储结构，在访问元素的时候只能通过线性的方式由前到后顺序访问，所以访问效率比数组要低。
### 30. 逆序对思路
### 31. 100个有序数组合并
归并排序，两个数组合并生成50个数组，生成25个数组，13个数组，6个数组，3个数组，2个数组，1个数组
### 32. 使用递归和非递归求二叉树的深度
### 33. 索引、链表的优缺点？
### 34. 找一个点为中心的圆里包含的所有的点。
### 35. 字典树的理解
1) 字典树，又称单词查找树，是一种树形结构，是一种哈希树的变种；
2) 根节点不包含字符，除根节点外的每一个子节点都包含一个字符；
从根节点到叶子节点，路径上经过的字符链接起来，就是该节点对应的字符串；
每个节点的所有子节点包含的字符都不同；
3) 典型应用是用于统计，排序和保存大量的字符串(不仅限于字符串)，经常被搜索引擎系统用于文本词频统计。
### 36. 快速排序的优化
1) 当我们每次划分的时候选择的基准数接近于整组数据的最大值或者最小值时，快速排序就会发生最坏的情况，但是每次选择的基准数都接近于最大数或者最小数的概率随着排序元素的增多就会越来越小，我们完全可以忽略这种情况。但是在数组有序的情况下，它也会发生最坏的情况，为了避免这种情况，我们在选择基准数的时候可以采用三数取中法来选择基准数。三数取中法：选择这组数据的第一个元素、中间的元素、最后一个元素，这三个元素里面值居中的元素作为基准数。
2) 当划分的子序列很小的时候(一般认为小于13个元素左右时)，我们在使用快速排序对这些小序列排序反而不如直接插入排序高效。因为快速排序对数组进行划分最后就像一颗二叉树一样，当序列小于13个元素时我们再使用快排的话就相当于增加了二叉树的最后几层的结点数目，增加了递归的次数。所以我们在当子序列小于13个元素的时候就改用直接插入排序来对这些子序列进行排序。
### 37. 海量数据的bitmap使用原理
1) BitMap解决海量数据寻找重复、判断个别元素是否在海量数据当中等问题；
2) 40亿个int占（40亿*4）/1024/1024/1024 大概为14.9G左右，很明显内存只有2G，放不下，因此不可能将这40亿数据放到内存中计算；40亿个int需要的内存空间为40亿/8/1024/1024大概为476.83MB;
